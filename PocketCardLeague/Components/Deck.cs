using Components;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json.Serialization;
using PocketCardLeague.Consts;
using PocketCardLeague.Enums;
using PocketCardLeague.Helpers;
using PocketCardLeague.SpriteMaps;
using Helpers;

namespace PocketCardLeague.Components;

public class Deck : Panel
{
    public string DeckName { get; set; } = string.Empty;
    public List<PokemonCardComponent> MainDeck { get; set; } = [];
    public List<BerryCardComponent> SideDeck { get; set; } = [];
    public PokemonCardComponent? FaceCard { get; set; }

    [JsonIgnore] public bool AutoBuild { get; set; } = false;
    private bool _needsBuild = false;

    /// <summary>
    /// Gives you a tuple with the minimum and maximum level of the Pokemon cards in the main deck. If the main deck is empty, both values will be 0.
    /// </summary>
    [JsonIgnore]
    public (int Min, int Max) LevelRange => (MainDeck.Min(c => c.Card?.Level ?? 0), MainDeck.Max(c => c.Card?.Level ?? 0));

    /// <summary>
    /// Gets a list of unique types in the main deck, ordered by frequency (most common first).
    /// </summary>
    [JsonIgnore]
    public List<PokemonType> Types => [.. MainDeck.SelectMany(c => c.Types).GroupBy(t => t).OrderByDescending(g => g.Count()).Select(g => g.Key)];

    /// <summary>
    /// Gets a list of unique costs in the main deck, ordered by the frequency of their occurrence (most common first).
    /// </summary>
    /// <remarks>Note that this is not a count of how many cards have each cost, but rather a list of
    /// the distinct costs sorted by how many cards have that cost. For example, if you have 10 cards
    /// that cost Green and 5 cards that cost Red, the list will be [Green, Red], not [Green x10, Red x5].</remarks>
    [JsonIgnore]
    public List<BerryEnergyType> Costs => [.. MainDeck.SelectMany(c => c.Cost).GroupBy(t => t).OrderByDescending(g => g.Count()).Select(g => g.Key)];

    /// <summary>
    /// Gets a list of berry types, ordered by their frequency across all side decks.
    /// </summary>
    /// <remarks>The list is generated by selecting all berry types from each side deck, grouping them by
    /// type, and ordering the groups by their count in descending order. This property provides a quick overview of the
    /// most common berry types used.</remarks>
    [JsonIgnore]
    public List<BerryEnergyType> Berries => [.. SideDeck.SelectMany(c => c.BerryTypes).GroupBy(t => t).OrderByDescending(g => g.Count()).Take(4).Select(g => g.Key)];

    private readonly BitmapLabel _deckLabel;
    private readonly List<(BaseComponent Component, Vector2 Offset)> _overlays = [];

    [JsonConstructor]
    public Deck(string deckName) : base($"deckbox_{deckName}")
    {
        DeckName = deckName;

        var layout = CardLayoutLoader.DeckBoxLayout;
        _deckLabel = new BitmapLabel($"deckbox_name_{deckName}")
        {
            Text = deckName,
            FontFamily = Fonts.M6x11,
            FontSize = (int)layout.NameLabelFontSize,
            TextColor = Color.White,
            Alignment = TextAlignment.Center,
            MaxWidth = (int)layout.NameLabelMaxWidth,
        };
        Children.Add(_deckLabel);

        Background = new Color(50, 55, 65);
        Border = new Border(4, Color.Gray);

        OnPositionChanged += RepositionChildren;
    }

    public override void Update(GameTime gameTime)
    {
        if (AutoBuild && !_needsBuild)
        {
            _needsBuild = true;
            AutoBuild = false;
            BuildVisuals();
        }

        base.Update(gameTime);
    }

    /// <summary>
    /// Builds all visual overlay children (face card, level, types, costs) from current deck data.
    /// Call this after setting MainDeck, SideDeck, and FaceCard.
    /// </summary>
    public void BuildVisuals()
    {
        // Clear previous overlays
        foreach (var (component, _) in _overlays)
            Children.Remove(component);
        _overlays.Clear();

        var layout = CardLayoutLoader.DeckBoxLayout;
        var boxWidth = (int)Size.X;
        var boxHeight = (int)Size.Y;

        // Face card sprite centered in the deckbox
        if (FaceCard is not null && FaceCard.SpriteIdentifier is not null)
        {
            var result = ContentHelper.GetTextureResult<PokemonSpriteAtlas>(FaceCard.Card?.BasePokemon.SpriteIdentifier ?? "");
            if (result is not null)
            {
                var spriteScale = layout.FaceCardScale;
                var scaledW = result.AtlasEntry.FrameWidth * spriteScale;
                var scaledH = result.AtlasEntry.FrameHeight * spriteScale;
                var faceSprite = new Sprite($"deck_face_{DeckName}")
                {
                    Scale = new Vector2(spriteScale, spriteScale),
                    Bob = BobDirection.Up,
                    BobDistance = layout.FaceCardBobDistance,
                };
                faceSprite.SetFromAtlas(result);
                faceSprite.Origin = Vector2.Zero;
                AddOverlay(faceSprite, new Vector2(
                    (boxWidth - scaledW) / 2f,
                    layout.FaceCardOffsetY + (layout.FaceCardAreaHeight - scaledH) / 2f));
            }
        }

        // Level range label in the top-right corner
        if (MainDeck.Count > 0)
        {
            var (min, max) = LevelRange;
            var lvText = min == max ? $"Lv. {min}" : $"Lv. {min} ~ {max}";
            var lvLabel = new BitmapLabel($"deck_lv_{DeckName}")
            {
                Text = lvText,
                FontFamily = Fonts.M6x11,
                FontSize = (int)layout.LevelLabelFontSize,
                TextColor = Color.White,
                Alignment = TextAlignment.Right,
                MaxWidth = (int)(boxWidth - layout.LevelLabelX * 2),
                Border = new Border((int)layout.LevelLabelBorderWidth, new Color(25, 25, 25, 200)),
            };
            AddOverlay(lvLabel, new Vector2(layout.LevelLabelX, layout.LevelLabelY));
        }

        // Types row — bottom, left to right
        var typeIconScale = layout.TypesIconScale;
        var typeIconW = (int)(12 * typeIconScale);
        var typeIconH = (int)(11 * typeIconScale);
        var typeSpacing = layout.TypesSpacing;
        var typeY = boxHeight - layout.TypesMarginBottom - typeIconH;

        for (int i = 0; i < Types.Count; i++)
        {
            var typeName = Types[i].ToString().ToLowerInvariant();
            var typeResult = ContentHelper.GetTextureResult<TypesSpriteAtlas>(typeName);
            if (typeResult is not null)
            {
                var typeSprite = new Sprite($"deck_type_{i}_{DeckName}")
                {
                    Scale = new Vector2(typeIconScale, typeIconScale),
                };
                typeSprite.SetFromAtlas(typeResult);
                typeSprite.Origin = Vector2.Zero;
                AddOverlay(typeSprite, new Vector2(layout.TypesMarginX + i * (typeIconW + typeSpacing), typeY));
            }
        }

        // Costs row — above types, left to right
        var dotScale = layout.CostsDotScale;
        var dotSize = (int)(5 * dotScale);
        var dotSpacing = layout.CostsSpacing;
        var dotY = typeY - dotSize - layout.CostsGapAboveTypes;

        for (int i = 0; i < Costs.Count; i++)
        {
            var berryName = "berry_" + Costs[i].ToString().ToLowerInvariant();
            var berryResult = ContentHelper.GetTextureResult<BerriesSpriteAtlas>(berryName);
            if (berryResult is not null)
            {
                var costSprite = new Sprite($"deck_cost_{i}_{DeckName}")
                {
                    Scale = new Vector2(dotScale, dotScale),
                };
                costSprite.SetFromAtlas(berryResult);
                costSprite.Origin = Vector2.Zero;
                AddOverlay(costSprite, new Vector2(layout.CostsMarginX + i * (dotSize + dotSpacing), dotY));
            }
        }
    }

    private void AddOverlay(BaseComponent component, Vector2 offset)
    {
        component.Position = new Anchor(offset, Position);
        _overlays.Add((component, offset));
        Children.Add(component);
    }

    private void RepositionChildren()
    {
        _deckLabel.Position = new Anchor(new Vector2(0, CardLayoutLoader.DeckBoxLayout.NameLabelY), Position);
        foreach (var (component, offset) in _overlays)
            component.Position = new Anchor(offset, Position);
    }
}
