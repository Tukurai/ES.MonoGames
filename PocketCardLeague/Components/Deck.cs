using Components;
using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json.Serialization;
using PocketCardLeague.Enums;
using Microsoft.Xna.Framework.Graphics;
using System.Runtime.InteropServices.Swift;
using PocketCardLeague.Consts;
using PocketCardLeague.SpriteMaps;
using Helpers;

namespace PocketCardLeague.Components;

public class Deck : Panel
{
    public string DeckName { get; set; } = string.Empty;
    public List<PokemonCard> MainDeck { get; set; } = [];
    public List<BerryCard> SideDeck { get; set; } = [];
    public PokemonCard? FaceCard { get; set; }

    /// <summary>
    /// Gives you a tuple with the minimum and maximum level of the Pokemon cards in the main deck. If the main deck is empty, both values will be 0.
    /// </summary>
    [JsonIgnore]
    public (int Min, int Max) LevelRange => (MainDeck.Min(c => c.Level), MainDeck.Max(c => c.Level));

    /// <summary>
    /// Gets a list of unique types in the main deck, ordered by frequency (most common first).
    /// </summary>
    [JsonIgnore]
    public List<PokemonType> Types => [.. MainDeck.SelectMany(c => c.Types).GroupBy(t => t).OrderByDescending(g => g.Count()).Select(g => g.Key)];

    /// <summary>
    /// Gets a list of unique costs in the main deck, ordered by the frequency of their occurrence (most common first).
    /// </summary>
    /// <remarks>Note that this is not a count of how many cards have each cost, but rather a list of
    /// the distinct costs sorted by how many cards have that cost. For example, if you have 10 cards
    /// that cost Green and 5 cards that cost Red, the list will be [Green, Red], not [Green x10, Red x5].</remarks>
    [JsonIgnore]
    public List<BerryEnergyType> Costs => [.. MainDeck.SelectMany(c => c.Cost).GroupBy(t => t).OrderByDescending(g => g.Count()).Select(g => g.Key)];

    /// <summary>
    /// Gets a list of berry types, ordered by their frequency across all side decks.
    /// </summary>
    /// <remarks>The list is generated by selecting all berry types from each side deck, grouping them by
    /// type, and ordering the groups by their count in descending order. This property provides a quick overview of the
    /// most common berry types used.</remarks>
    [JsonIgnore]
    public List<BerryEnergyType> Berries => [.. SideDeck.SelectMany(c => c.BerryTypes).GroupBy(t => t).OrderByDescending(g => g.Count()).Take(4).Select(g => g.Key)];

    private readonly BitmapLabel _deckLabel;
    private readonly List<(BaseComponent Component, Vector2 Offset)> _overlays = [];

    [JsonConstructor]
    public Deck(string deckName) : base($"deckbox_{deckName}")
    {
        DeckName = deckName;

        _deckLabel = new BitmapLabel($"deckbox_name_{deckName}")
        {
            Text = deckName,
            FontFamily = Fonts.M6x11,
            FontSize = 36,
            TextColor = Color.White,
            Alignment = TextAlignment.Center,
            MaxWidth = 228,
        };
        Children.Add(_deckLabel);

        Background = new Color(50, 55, 65);
        Border = new Border(4, Color.Gray);

        OnPositionChanged += RepositionChildren;
    }

    /// <summary>
    /// Builds all visual overlay children (face card, level, types, costs) from current deck data.
    /// Call this after setting MainDeck, SideDeck, and FaceCard.
    /// </summary>
    public void BuildVisuals()
    {
        // Clear previous overlays
        foreach (var (component, _) in _overlays)
            Children.Remove(component);
        _overlays.Clear();

        var boxWidth = (int)Size.X;
        var boxHeight = (int)Size.Y;

        // Face card sprite centered in the deckbox
        if (FaceCard is not null)
        {
            var result = ContentHelper.GetTextureResult<PokemonSpriteAtlas>(FaceCard.SpriteIdentifier);
            if (result is not null)
            {
                var spriteScale = 4f;
                var scaledW = result.AtlasEntry.FrameWidth * spriteScale;
                var scaledH = result.AtlasEntry.FrameHeight * spriteScale;
                var faceSprite = new Sprite($"deck_face_{DeckName}")
                {
                    Scale = new Vector2(spriteScale, spriteScale),
                    Bob = BobDirection.Up,
                    BobDistance = 8,
                };
                faceSprite.SetFromAtlas(result);
                faceSprite.Origin = Vector2.Zero;
                AddOverlay(faceSprite, new Vector2((boxWidth - scaledW) / 2f, 20 + (200 - scaledH) / 2f));
            }
        }

        // Level range label in the top-right corner
        if (MainDeck.Count > 0)
        {
            var (min, max) = LevelRange;
            var lvText = min == max ? $"Lv. {min}" : $"Lv. {min} ~ {max}";
            var lvLabel = new BitmapLabel($"deck_lv_{DeckName}")
            {
                Text = lvText,
                FontFamily = Fonts.M6x11,
                FontSize = 32,
                TextColor = Color.White,
                Alignment = TextAlignment.Right,
                MaxWidth = boxWidth - 24,
                Border = new Border(2, new Color(25, 25, 25, 200)),
            };
            AddOverlay(lvLabel, new Vector2(12, 8));
        }

        // Types row — bottom, left to right
        var typeIconScale = 4f;
        var typeIconW = (int)(12 * typeIconScale);
        var typeIconH = (int)(11 * typeIconScale);
        var typeSpacing = 4;
        var typeY = boxHeight - 12 - typeIconH;

        for (int i = 0; i < Types.Count; i++)
        {
            var typeName = Types[i].ToString().ToLowerInvariant();
            var typeResult = ContentHelper.GetTextureResult<TypesSpriteAtlas>(typeName);
            if (typeResult is not null)
            {
                var typeSprite = new Sprite($"deck_type_{i}_{DeckName}")
                {
                    Scale = new Vector2(typeIconScale, typeIconScale),
                };
                typeSprite.SetFromAtlas(typeResult);
                typeSprite.Origin = Vector2.Zero;
                AddOverlay(typeSprite, new Vector2(12 + i * (typeIconW + typeSpacing), typeY));
            }
        }

        // Costs row — above types, left to right
        var dotScale = 4f;
        var dotSize = (int)(5 * dotScale);
        var dotSpacing = 4;
        var dotY = typeY - dotSize - 8;

        for (int i = 0; i < Costs.Count; i++)
        {
            var berryName = "berry_" + Costs[i].ToString().ToLowerInvariant();
            var berryResult = ContentHelper.GetTextureResult<BerriesSpriteAtlas>(berryName);
            if (berryResult is not null)
            {
                var costSprite = new Sprite($"deck_cost_{i}_{DeckName}")
                {
                    Scale = new Vector2(dotScale, dotScale),
                };
                costSprite.SetFromAtlas(berryResult);
                costSprite.Origin = Vector2.Zero;
                AddOverlay(costSprite, new Vector2(12 + i * (dotSize + dotSpacing), dotY));
            }
        }
    }

    private void AddOverlay(BaseComponent component, Vector2 offset)
    {
        component.Position = new Anchor(offset, Position);
        _overlays.Add((component, offset));
        Children.Add(component);
    }

    private void RepositionChildren()
    {
        _deckLabel.Position = new Anchor(new Vector2(0, 320), Position);
        foreach (var (component, offset) in _overlays)
            component.Position = new Anchor(offset, Position);
    }
}
