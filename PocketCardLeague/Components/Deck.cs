using Components;
using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using PocketCardLeague.Enums;
using Microsoft.Xna.Framework.Graphics;
using System.Runtime.InteropServices.Swift;
using PocketCardLeague.Consts;

namespace PocketCardLeague.Components;

public class Deck : Panel
{
    public string DeckName { get; set; } = string.Empty;
    public List<PokemonCard> MainDeck { get; set; } = [];
    public List<BerryCard> SideDeck { get; set; } = [];
    public PokemonCard? FaceCard { get; set; }

    /// <summary>
    /// Gives you a tuple with the minimum and maximum level of the Pokemon cards in the main deck. If the main deck is empty, both values will be 0.
    /// </summary>
    public (int Min, int Max) LevelRange => (MainDeck.Min(c => c.Level), MainDeck.Max(c => c.Level));

    /// <summary>
    /// Gets a list of unique types in the main deck, ordered by frequency (most common first).
    /// </summary>
    public List<PokemonType> Types => [.. MainDeck.SelectMany(c => c.Types).GroupBy(t => t).OrderByDescending(g => g.Count()).Select(g => g.Key)];

    /// <summary>
    /// Gets a list of unique costs in the main deck, ordered by the frequency of their occurrence (most common first).
    /// </summary>
    /// <remarks>Note that this is not a count of how many cards have each cost, but rather a list of 
    /// the distinct costs sorted by how many cards have that cost. For example, if you have 10 cards 
    /// that cost Green and 5 cards that cost Red, the list will be [Green, Red], not [Green x10, Red x5].</remarks>
    public List<BerryType> Costs => [.. MainDeck.SelectMany(c => c.Cost).GroupBy(t => t).OrderByDescending(g => g.Count()).Select(g => g.Key)];

    /// <summary>
    /// Gets a list of berry types, ordered by their frequency across all side decks.
    /// </summary>
    /// <remarks>The list is generated by selecting all berry types from each side deck, grouping them by
    /// type, and ordering the groups by their count in descending order. This property provides a quick overview of the
    /// most common berry types used.</remarks>
    public List<BerryType> Berries => [.. SideDeck.SelectMany(c => c.BerryTypes).GroupBy(t => t).OrderByDescending(g => g.Count()).Select(g => g.Key)];

    public Deck(string deckName) : base($"deckbox_{deckName}")
    {
        DeckName = deckName;

        var deckLabel = new BitmapLabel($"deckbox_name_{deckName}", new Anchor(new Vector2(0, 320), Position)) { 
            Size = new Vector2(228, 32),
            FontFamily = Fonts.M6x11,
        };
        Children.Add(deckLabel);
    }

    public override void Update(GameTime gameTime)
    {
        base.Update(gameTime);
    }

    public override void Draw(SpriteBatch spriteBatch)
    {
        base.Draw(spriteBatch);
    }
}
